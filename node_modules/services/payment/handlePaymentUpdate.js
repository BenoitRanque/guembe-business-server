const pg = require('utils/pg')

const updatePayment = require('services/payment/updatePayment')
const updatePaymentStatus = require('services/payment/updatePaymentStatus')
const createInvoicesForSale = require('services/invoice/createInvoicesForSale')
const createSaleVouchers = require('services/voucher/createSaleVouchers')
const getPayment = require('services/payment/getPayment')
const getPaymentUpdates = require('services/payment/getPaymentUpdates')
const getPaymentSaleId = require('services/payment/getPaymentSaleId')

module.exports = async function handlePaymentRefresh ({ khipuPayment }) {
  const pgClient = await pg.connect()

  const payment_id = khipuPayment.transaction_id

  try {
    await pgClient.query('BEGIN')
    const payment = await getPayment({ payment_id }, pgClient)
    const paymentUpdates = await getPaymentUpdates({ payment_id }, pgClient)

    await updatePayment({ payment_id, update: khipuPayment }, pgClient)

    const paymentStatusUpdate = await updatePaymentStatus({ payment_id, update: khipuPayment, payment, paymentUpdates }, pgClient)
    if (paymentStatusUpdate.status === 'COMPLETED') {
      const sale_id = await getPaymentSaleId({ payment_id }, pgClient)
      await createInvoicesForSale({ sale_id }, pgClient)
      await createSaleVouchers({ sale_id }, pgClient)
    }

    await pgClient.query('COMMIT')

    return {
      payment_id
    }
  } catch (error) {
    await pgClient.query('ROLLBACK')
    throw error
  } finally {
    pgClient.release()
  }
}